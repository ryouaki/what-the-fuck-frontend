# 开放封闭原则

【OCP】软件实体（类，模块，函数等）应该是可扩展的，但是不可以修改。

*如果程序中，一处改动就会引起连锁反应，导致一系列模块跟着修改，那么设计就是不合理的。而适配器模式，桥接模式，中介者模式，微内核模式，都可以很好的帮助我们解决这一问题。实现开放闭合原则*

### 开放闭合原则特点
- 对于扩展是开放的
  > 这意味着，模块的行为是可扩展的，当应用的需求发生改变的时候，我们可以对模块进行扩展，使其具有满足那些改变的新行为。也就是说我们可以改变功能
- 对于更改是封闭的
  > 对于模块行为扩展的时候，不必改动模块的原有逻辑，所有依赖都应该是无需改动的。

*看似非常矛盾的特点，如何做到这一点呢？*

### 如何满足开放闭合原则

- 继承和抽象，通过继承去扩展原有模块
- 代理模式，通过代理模式，对原有模块进行代理扩展
- 微内核模式，通过增加新的插件扩展内核功能
- 装饰器模式，在不修改原有类的前提下进行扩展。

然而现实是残酷的，我们无法100%做到开放闭合原则，因为我们必须面对无法预知的变化。因此我们只能尽力的去对频繁发生变化的功能进行不断的调整，使之满足OCP原则来提高系统的扩展性，复用性和稳定性。

### 开放闭合原则非常难以满足

为了尽可能做到开放闭合原则，我们要对未来将要产生的变化有一定预测，并且还要具备有能力做抽象的开发人员。但是实际情况往往事与愿违。我们无法保障我们的对未来需求变化的预知是正确的，尤其国内互联网行业。而且我们也不一定具备优秀的具有抽象能力的开发人员。而通过预测变化提前进行抽象就会有以下几个问题产生：

- 过度抽象，过度抽象会导致一旦变化与预测不符就会带来非常大的麻烦。导致设计难以扩展
- 不成熟的抽象，即使与预测相符，但是由于抽象设计不合理带来的难以适应新的变化
- 难以预测的变化，国内互联网行业变化非常之快，很难预测到下一步对手是如何变化的，而我们也要随时响应业务需要做出快速响应

为了解决以上难题，我们应该在事情发生的时候再去对频繁发生变化的地方进行抽象，使之满足OCP原则。避免过度抽象和不成熟的抽象。
